---
layout: post
excerpt: 3 recent papers that are built on generative adversarial nets
permalink: /Deep-Learning-Research-Review-Week-1-Generative-Adversarial-Nets
images:
  - url: /assets/Cover5th.png
---
<link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet">
<img src="/assets/Cover5th.png">
<p><em>Starting this week, I&rsquo;ll be doing a new series called Deep Learning Research Review. Every </em><em>couple weeks</em><em> or so</em><em>, I&rsquo;ll be summarizing and explaining research papers in specific subfields of deep learning. This </em><em>week</em><em> I&rsquo;ll begin with Generative Adversarial Networks.&nbsp;</em>&nbsp;</p>
<h2><strong>Introduction</strong>&nbsp;</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.quora.com/What-are-some-recent-and-potentially-upcoming-breakthroughs-in-unsupervised-learning" target="_blank">According to Yann LeCun</a>, &ldquo;adversarial training is the coolest thing since sliced bread&rdquo;. I&rsquo;m inclined to believe so because I don&rsquo;t think sliced bread ever created this much buzz and excitement within the deep learning community. In this post, we&rsquo;ll be looking at 3 papers that built on the pioneering <a href="https://arxiv.org/pdf/1406.2661v1.pdf" target="_blank">work</a> of Ian Goodfellow in 2014.&nbsp;&nbsp;</p>
<h2><strong>Quick Summary of GANs</strong>&nbsp;</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I briefly mentioned Ian Goodfellow&rsquo;s Generative Adversarial Network <a href="https://arxiv.org/pdf/1406.2661v1.pdf" target="_blank">paper</a> in one of my prior blog posts, <a href="https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html" target="_blank">9 Deep Learning Papers You Should Know About</a>.&nbsp; The basic idea of these networks is that you have 2 models, a generative model and a discriminative model. The discriminative model has the task of determining whether a given image looks natural (an image from the dataset) or looks like it has been artificially created. The task of the generator is to create natural looking&nbsp;images that are similar&nbsp;to the original data distribution. This can be thought of as a zero-sum or minimax two player game. The analogy used in the paper is that the generative model is like &ldquo;a team of counterfeiters, trying to produce and use fake currency&rdquo; while the discriminative model is like &ldquo;the police, trying to detect the counterfeit currency&rdquo;. The generator is trying to fool the discriminator while the discriminator is trying to not get fooled by the generator. As the models train through alternating optimization, both methods are improved until a point where the &ldquo;counterfeits are indistinguishable from the genuine articles&rdquo;.&nbsp;</p>
<h2><span style="text-decoration: underline;"><a href="https://arxiv.org/pdf/1506.05751v1.pdf" target="_blank"><strong>Laplacian Pyramid of Adversarial Networks</strong></a></span></h2>
<p><span style="text-decoration: underline;">Introduction</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So, one of the most important uses of adversarial networks is the ability to create natural looking images after training the generator for a sufficient amount of time. These are some samples of what the generator outputted in Goodfellow&rsquo;s 2014 paper.&nbsp;</p>
<!-- Pic 1 -->
<img src="/assets/Gan1.png">
<p>As you can see, the generator worked well with digits and faces, but it created very fuzzy and vague images when using the CIFAR-10 dataset.&nbsp;&nbsp;</p>
<p>In order to fix this problem, Emily Denton, Soumith Chintala, Arthur Szlam, and Rob Fergus published the paper titled &ldquo;Deep Generative Image Models using Lapalacian Pyramid of Adversarial Networks&rdquo;. The main contribution of the paper is a type of network architecture that produces <strong>high-quality generated images that are mistaken for real images almost 40% of the time when assessed by human evaluators</strong>.&nbsp;&nbsp;</p>
<p><span style="text-decoration: underline;">Approach</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Before getting into the paper, let&rsquo;s think about the job of the generator in a GAN. It has to produce a large, complex, and natural image that is good enough to convince a trained discriminator. Not such an easy task in one shot. The way the authors combat this is by using multiple CNN models to sequentially generate images in increasing scales. As Emily Denton said in her <a href="https://www.youtube.com/watch?v=JEJk-Ug_ebI">talk</a> on LAPGANs,&nbsp;</p>
<!-- Pic 2 -->
<img src="/assets/Gan2.png">
<p>The approach of this paper is to build a Laplacian Pyramid of generative models. For those that aren&rsquo;t familiar, a Laplacian pyramid is basically an image representation that consists of a series of filtered images at successively sparser densities (<a href="http://www.cs.utah.edu/~arul/report/node12.html">more info</a> for those interested). The idea is that each level of this pyramid representation contains information about the image at a particular scale. It is a sort of decomposition of the original image.&nbsp;</p>
<p>Let&rsquo;s review what the inputs and outputs are of a simple GAN. The generator takes in an input noise vector from a distribution and outputs an image. The discriminator takes in this image (or a real image from the training data) and outputs a scalar describing how &ldquo;real&rdquo; the image is. Now, let&rsquo;s look at a conditional GAN (CGAN). Everything remains the same, except that both the discriminator and the generator receive another piece of information as an input. This information is likely in the form of some sort of class label or another image.&nbsp;&nbsp;</p>
<p><span style="text-decoration: underline;">Network Architecture</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The authors propose a set of convnet models and that each layer of the pyramid will have a convnet associated with it. The change is the traditional GAN structure is that instead of having just one generator CNN that creates the whole image, we have a series of CNNs that create the image <strong>sequentially</strong> by slowly increasing the resolution (aka going along the pyramid) and refining images in a coarse to fine fashion. Each level has its own CNN and is trained on two components. One is a low resolution image and the other is a noise vector (which was the only input in traditional GANs). This is where the idea of CGANs come into play as there are multiple inputs. The output will be a generated image that is then upsampled and used as input to the next level of the pyramid. This method is effective because the generators in each level are able to utilize information from different resolutions in order to create more finely grained outputs in the successive layers.</p>
<!-- Pic 3 and 4 -->
<img src="/assets/Gan3.png">
<p></p>
<img src="/assets/Gan4.png">
<h2><span style="text-decoration: underline;"><a href="https://arxiv.org/pdf/1605.05396.pdf" target="_blank"><strong>Generative Adversarial Text to Image Synthesis</strong></a></span></h2>
<p><span style="text-decoration: underline;">Introduction</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This paper was released just this past June and looks into the task of <strong>converting text descriptions into images</strong>. For example, the input to the network could be &ldquo;a flower with pink petals&rdquo; and the output is a generated image that contains those characteristics. So this task involves two main components. One is utilizing forms of&nbsp;natural language processing to understand the input description and the other is a generative network that is able to output an accurate and natural image representation. One note that the authors make is that the task of going from text to image is actually a lot harder than that of going from image to text (remember Karpathy&rsquo;s <a href="https://arxiv.org/pdf/1412.2306v2.pdf">paper</a>). This is because of the incredible amount of pixel configurations and because we can&rsquo;t really decompose the task into just predicting the next word (the way that image to text works).&nbsp;</p>
<p><span style="text-decoration: underline;">Approach</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The approach the authors take is training a GAN that is conditioned on text features created by a&nbsp;recurrent text encoder (won't go too much into this, but here's the <a href="https://arxiv.org/pdf/1605.05395v1.pdf" target="_blank">paper</a> for those interested). Both the generator and the discriminator use these features at points in their respective network architectures. This is what enables the GAN to make the correlation between the input description and the generated image.&nbsp;&nbsp;</p>
<p><span style="text-decoration: underline;">Network Architecture</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Let&rsquo;s look at the generator first. We have our noise vector z along with a text encoding as the inputs to the network. Basically, this text encoding is a way of encapsulating information about the input description in a way that it can then be concatenated to the noise vector (see image below for a visualization). Deconv layers are then used to transform the input vector into the synthetic image.&nbsp;&nbsp;</p>
<p>The discriminator takes in an image, passes it through a series of conv layers (with BatchNorm and leaky ReLUs). When the spatial dimensions finally get to 4x4, the network performs a depth concatenation with that text encoding we were talking about earlier. After this, there are 2 more conv layers and the output is (as always) a score for the realness of the image.</p>
<!-- Pic 5 -->
<img src="/assets/Gan5.png">
<p><span style="text-decoration: underline;">Training</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One of the interesting things about this model is the way that it has to be trained. If you think closely about the task at hand, the generator has to get two jobs right. One is that it has to generate natural and plausible looking images. The other is that the images must correlate to the given text description. The discriminator, thus, must also keep these two things into account, making sure that &ldquo;fake&rdquo; or unnatural images are rejected as well as images that mismatch the text. In order to create these versatile models, the authors train with three types of&nbsp;data:&nbsp;{real image, right text}, {fake image, right text},&nbsp;and {real image, wrong text}. With that last training data type, the discriminator must learn to reject mismatched images (even if they look very natural).&nbsp;</p>
<!-- Pic 6 -->
<img src="/assets/Gan6.png">
<h2><span style="text-decoration: underline;"><a href="https://arxiv.org/pdf/1609.04802v1.pdf" target="_blank"><strong>Super Resolution using GANs</strong></a></span></h2>
<p><span style="text-decoration: underline;">Introduction</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As a testament to the type of rapid innovation that takes place in this field, the team at Twitter Cortex released this paper only a couple weeks ago. The model being proposed in this paper is a super-resolution generative adversarial network, or SRGAN (Will we ever run out of these acronyms?). The main contribution is a brand new loss function (better than plain old MSE) that enables the network to <strong>recover realistic textures and fine grained details from images that have been heavily </strong><strong>downsampled</strong>.&nbsp;&nbsp;</p>
<p><span style="text-decoration: underline;">Approach</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Let&rsquo;s first take a look at this new perceptual loss function that was introduced. This loss function can be divided into two parts, the adversarial loss and the content loss. From a high level, the adversarial loss encourages images that look natural (look like they&rsquo;re from the distribution) and the content loss makes sure that the new resolution image has similar features to the original low res image.&nbsp;&nbsp;</p>
<p><span style="text-decoration: underline;">Network Architecture</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Okay, now let&rsquo;s get into the specifics. Let&rsquo;s start off with a high resolution version of a given image and then a lower resolution version. We want to train our generator so that given the low resolution image, we can have an output that&rsquo;s as close to the high res version as possible. This output is called a super-resolved image. The discriminator will then be trained to distinguish between these images. Same old same old, right? The generator network architecture uses a set of B residual blocks&nbsp;that contain ReLUs and BatchNorm and conv layers. Once the low res image passes through those blocks, there are two deconv layers that enable the increase of the resolution. Then, looking at the discriminator, we have eight convolutional layers that lead into a sigmoid activation function which outputs the probabilities of whether the image is real (high res) or artificial (super res). &nbsp;</p>
<!-- Pic 7 -->
<img src="/assets/Gan7.png">
<p><span style="text-decoration: underline;">Loss Function</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now let&rsquo;s look at that new loss function. It is actually a weighted sum of individual loss functions. The first is called a content loss. Basically, it is a Euclidean distance loss between the feature maps (in a pretrained VGG network) of the new reconstructed image (output of the network) and the actual high res training image. From what I understand, the main goal is to ensure that the content of the two images are similar by looking at their respective feature activations after feeding them into a trained convnet (Comment below if anyone has other ideas!). The other major loss function the authors defined is the adversarial loss. This one is similar to what you normally expect from GANs. It encourages outputs that are similar to the original data distribution through negative log likelihood. A regularization loss caps off the trio of functions. With this novel loss function, the generator makes sure to output larger res images that look natural and still retain a similar pixel space when compared to the low res version.&nbsp;</p>
<!-- Pic 8 -->
<img src="/assets/Gan8.png">
<p><strong>Quick general side n</strong><strong>ote</strong>: GANs use a largely unsupervised training process (all you need to have is a dataset of real images, no labels or anything). This means that we can take advantage of a lot of the unstructured image data that is available today. After training, we can use the output or intermediate layers as feature extractors that can be used for other classifiers, which now won&rsquo;t need as much training data to achieve good accuracy.&nbsp;</p>
<p><strong>Paper that I couldn&rsquo;t get to, but still insanely cool</strong>: <a href="http://arxiv.org/pdf/1511.06434v2.pdf" target="_blank">DCGANs</a>. The authors didn&rsquo;t do anything crazy. They just trained a really really large convnet, but the trick is that they had the right hyperparameters to really make the training work (aka BatchNorm, Adam, Leaky ReLUs).&nbsp;</p>
<p><strong>GANs that could change the fashion industry</strong>: <a href="https://www.youtube.com/watch?v=9c4z6YsBGQ0" target="_blank">https://www.youtube.com/watch?v=9c4z6YsBGQ0</a>&nbsp;&nbsp;</p>
<p>Dueces. <i class="em em-v"></i></p>
<a href = "/assets/Sources5.txt" target= "_blank"> Sources</a>
<p></p>
<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-80811190-1', 'auto');
  ga('send', 'pageview');
</script>
